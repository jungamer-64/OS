# カーネルとユーザーランドの分離 - アーキテクチャドキュメント

## 概要

このドキュメントでは、Tiny OSにおけるカーネル空間（Ring 0）とユーザー空間（Ring 3）の分離アーキテクチャについて説明します。

---

## アーキテクチャ原則

### 1. 完全な分離

- **コンパイル時分離**: カーネルとユーザーランドは独立したクレートとしてビルド
- **実行時分離**: ページテーブルによるメモリ保護
- **インターフェース**: システムコールのみが唯一の通信手段

### 2. セキュリティ

- **W^X (Write XOR Execute)**: 書き込み可能なページは実行不可
- **ユーザーポインタ検証**: すべてのユーザー空間ポインタを検証
- **最小権限**: カーネルは必要最小限の機能のみを公開

---

## メモリレイアウト

### 仮想アドレス空間

```
0x0000_0000_0000_0000 - 0x0000_7FFF_FFFF_FFFF  User Space (128TB)
  ├─ 0x0000_0000_0040_0000 - 0x0000_0000_00BF_FFFF  User Code (.text)
  ├─ 0x0000_0000_00C0_0000 - 0x0000_0000_013F_FFFF  User Data (.data, .bss)
  └─ 0x0000_7FFF_FFF0_0000 - 0x0000_7FFF_FFFF_FFFF  User Stack

0x0000_8000_0000_0000 - 0xFFFF_FFFF_FFFF_FFFF  Kernel Space (128TB)
  ├─ 0xFFFF_8000_0000_0000 - ...                   Physical Memory Mapping
  └─ 0xFFFF_FFFF_8000_0000 - ...                   Kernel Code & Data
```

### ページテーブル構成

- **L4エントリ 0-255**: ユーザー空間マッピング
- **L4エントリ 256-511**: カーネル空間マッピング（全プロセスで共有）

---

## システムコールインターフェース

### 呼び出し規約

- **機構**: `syscall`/`sysret` 命令
- **番号**: `rax` レジスタ
- **引数**: `rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9` (最大6引数)
- **戻り値**: `rax` (成功時は値、エラー時は負の値)

### 実装されたシステムコール

| 番号 | 名前 | 機能 |
|------|------|------|
| 0 | read | ファイルディスクリプタから読み取り |
| 1 | write | ファイルディスクリプタへ書き込み |
| 2 | open | ファイルを開く |
| 3 | close | ファイルを閉じる |
| 60 | exit | プロセスを終了 |
| 39 | getpid | プロセスIDを取得 |
| 57 | fork | プロセスを複製 |
| 59 | execve | プログラムを実行 |
| 61 | wait4 | 子プロセスの終了を待機 |
| 9 | mmap | メモリをマッピング |
| 11 | munmap | メモリマッピングを解除 |
| 22 | pipe | パイプを作成 |

詳細は [`syscall_interface.md`](syscall_interface.md) を参照。

---

## プロセス管理

### プロセス構造

各プロセスは以下を保持：

- **PID**: 一意なプロセスID
- **ページテーブル**: 独立した仮想アドレス空間
- **レジスタコンテキスト**: CPU状態
- **カーネルスタック**: システムコール実行用
- **ファイルディスクリプタテーブル**: 開いているファイル

### プロセスライフサイクル

1. **作成**: `fork()` または `create_user_process()`
2. **実行**: `exec()` で新しいプログラムをロード
3. **終了**: `exit()` でリソースを解放
4. **回収**: 親プロセスが `wait()` でゾンビを回収

---

## ELFローダー

### 対応形式

- **ELF64**: 64ビットELFバイナリ
- **実行可能**: ET_EXEC, ET_DYN
- **アーキテクチャ**: x86-64

### ロードプロセス

1. **ヘッダー検証**: マジック番号、アーキテクチャ確認
2. **プログラムヘッダー解析**: LOADセグメントを特定
3. **メモリマッピング**: 各セグメントを適切なパーミッションでマップ
4. **BSS初期化**: 未初期化データ領域をゼロクリア
5. **スタック設定**: ユーザースタックを確保
6. **エントリポイント**: プログラム開始アドレスを設定

### セキュリティチェック

- ✅ ユーザー空間範囲検証
- ✅ W^X強制
- ✅ 整数オーバーフロー防止
- ✅ セグメントアライメント確認

---

## ビルドシステム

### ビルド順序

```
1. libuser (ユーザーランド標準ライブラリ)
   ↓
2. ユーザープログラム (shell, init, test)
   ↓
3. kernel (ユーザープログラムを埋め込み)
```

### ワークスペース構成

```
Cargo.toml (workspace root)
├─ kernel/ (カーネルクレート)
└─ userland/
   ├─ libuser/ (標準ライブラリ)
   └─ programs/
      ├─ shell/
      ├─ init/
      └─ test/
```

---

## セキュリティモデル

### メモリ保護

1. **ページ権限**: USER, WRITABLE, NO_EXECUTE フラグ
2. **範囲チェック**: すべてのユーザーポインタを検証
3. **スタックガード**: スタックオーバーフロー検出

### システムコールセキュリティ

1. **引数検証**: すべての引数を検証
2. **エラーハンドリング**: 適切なエラーコード返却
3. **リソース制限**: (将来実装予定)

---

## パフォーマンス考慮事項

### システムコールオーバーヘッド

- `syscall`/`sysret` 命令: ~200サイクル
- コンテキストスイッチ: ~1000サイクル
- ページテーブル切り替え: TLBフラッシュによるオーバーヘッド

### 最適化戦略

- カーネル空間の共有マッピングでTLBフラッシュを最小化
- システムコールのバッチ処理（将来）
- vDSO (virtual Dynamic Shared Object) の実装（将来）

---

## 今後の拡張

- [ ] シグナル機構
- [ ] 共有メモリ
- [ ] スレッドサポート
- [ ] 動的リンク
- [ ] セキュリティポリシー (SELinux風)

---

**バージョン**: Phase 5完了時点
**最終更新**: 2025-11-25
