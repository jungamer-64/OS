# システムコールインターフェース仕様書

このドキュメントは、Tiny OS のカーネルとユーザーランドの境界を定義するシステムコールインターフェースの完全な仕様を記述します。

## 概要

Tiny OS は x86-64 アーキテクチャの `syscall`/`sysret` 命令を使用してシステムコールを実装します。

### レジスタマッピング

システムコール時のレジスタ配置（System V AMD64 ABI 準拠）：

| レジスタ | 用途 | 説明 |
|---------|------|------|
| RAX | システムコール番号 | 呼び出すシステムコール |
| RDI | 引数 1 | 第1引数 |
| RSI | 引数 2 | 第2引数 |
| RDX | 引数 3 | 第3引数 |
| R10 | 引数 4 | 第4引数（注: RCXではない） |
| R8  | 引数 5 | 第5引数 |
| R9  | 引数 6 | 第6引数 |
| RAX | 戻り値 | システムコールの結果 |
| RCX | 保存用 | CPUが自動保存（ユーザーRIP） |
| R11 | 保存用 | CPUが自動保存（ユーザーRFLAGS） |

### 呼び出し規約

```asm
; ユーザーランドからの呼び出し例
mov rax, SYSCALL_NUMBER  ; システムコール番号
mov rdi, arg1            ; 第1引数
mov rsi, arg2            ; 第2引数
mov rdx, arg3            ; 第3引数
mov r10, arg4            ; 第4引数
mov r8,  arg5            ; 第5引数
mov r9,  arg6            ; 第6引数
syscall                  ; カーネルへ遷移
; RAX に戻り値
```

## エラーコード

すべてのシステムコールは `i64` 型の戻り値を返します。負の値はエラーを示します（Linux 互換）。

| コード | 名前 | 値 | 説明 |
|--------|------|-----|------|
| `SUCCESS` | 成功 | 0 | 操作が成功 |
| `EPERM` | 権限エラー | -1 | 操作が許可されていない |
| `ENOENT` | エントリなし | -2 | ファイルまたはディレクトリが存在しない |
| `ESRCH` | プロセスなし | -3 | プロセスが存在しない |
| `EINTR` | 割り込み | -4 | システムコールが割り込まれた |
| `EIO` | I/Oエラー | -5 | 入出力エラー |
| `EBADF` | 不正なFD | -9 | ファイルディスクリプタが無効 |
| `ECHILD` | 子プロセスなし | -10 | 子プロセスが存在しない |
| `EAGAIN` | リトライ | -11 | リソースが一時的に利用不可 |
| `ENOMEM` | メモリ不足 | -12 | メモリ割り当てに失敗 |
| `EFAULT` | 不正なアドレス | -14 | ポインタが無効 |
| `EINVAL` | 不正な引数 | -22 | 引数が無効 |
| `EPIPE` | パイプ破損 | -32 | パイプの読み取り側が閉じている |
| `ENOSYS` | 未実装 | -38 | システムコールが実装されていない |

## システムコール一覧

### 0: sys_write - ファイルへの書き込み

ファイルディスクリプタにデータを書き込みます。

**引数:**

- `arg1` (RDI): `fd` - ファイルディスクリプタ (u64)
- `arg2` (RSI): `buf` - 書き込むデータへのポインタ (u64)
- `arg3` (RDX): `len` - 書き込むバイト数 (u64)

**戻り値:**

- 成功時: 書き込まれたバイト数 (正の値)
- エラー時: 負のエラーコード
  - `EBADF`: 無効なファイルディスクリプタ
  - `EFAULT`: バッファポインタが無効（カーネル空間またはマッピングされていない）
  - `EINVAL`: 長さが無効（1MBを超える）
  - `EIO`: I/Oエラー
  - `EPIPE`: パイプが閉じている

**特殊なFD:**

- `0`: stdin（読み取り専用）
- `1`: stdout（標準出力、シリアルコンソール）
- `2`: stderr（標準エラー、stdout と同じ）

**使用例:**

```rust
let message = b"Hello, World!\n";
let result = syscall!(WRITE, 1, message.as_ptr() as u64, message.len() as u64);
if result < 0 {
    // エラー処理
}
```

---

### 1: sys_read - ファイルからの読み取り

ファイルディスクリプタからデータを読み取ります。

**引数:**

- `arg1` (RDI): `fd` - ファイルディスクリプタ (u64)
- `arg2` (RSI): `buf` - データを格納するバッファへのポインタ (u64)
- `arg3` (RDX): `len` - 読み取る最大バイト数 (u64)

**戻り値:**

- 成功時: 読み取られたバイト数 (正の値)
- EOF時: 0
- エラー時: 負のエラーコード
  - `EBADF`: 無効なファイルディスクリプタ
  - `EFAULT`: バッファポインタが無効
  - `EIO`: I/Oエラー
  - `EAGAIN`: リソースが一時的に利用不可（ノンブロッキングI/O）

**注意:**

- stdin (FD 0) からの読み取りは現在未実装（`ENOSYS`）

---

### 2: sys_exit - プロセスの終了

現在のプロセスを終了します。このシステムコールは返りません。

**引数:**

- `arg1` (RDI): `code` - 終了コード (i32として解釈)

**戻り値:**

- なし（このシステムコールは返らない）

**動作:**

1. プロセスを `Terminated` 状態に設定
2. 終了コードを保存
3. 親プロセスに通知（将来の実装）
4. スケジューラを呼び出して次のプロセスに切り替え

**使用例:**

```rust
syscall!(EXIT, 0);  // 正常終了
// ここには到達しない
```

---

### 3: sys_getpid - プロセスIDの取得

現在のプロセスのプロセスIDを取得します。

**引数:**

- なし

**戻り値:**

- プロセスID (正の値)

**使用例:**

```rust
let pid = syscall!(GETPID);
```

---

### 4: sys_alloc - メモリ割り当て（非推奨）

**ステータス:** 非推奨 - 代わりに `sys_mmap` を使用してください

メモリを割り当てます。

**引数:**

- `arg1` (RDI): `size` - 割り当てるバイト数 (u64)

**戻り値:**

- 成功時: 割り当てられたメモリのアドレス
- エラー時: `ENOSYS`（現在未実装）

---

### 5: sys_dealloc - メモリ解放（非推奨）

**ステータス:** 非推奨 - 代わりに `sys_munmap` を使用してください

割り当てられたメモリを解放します。

**引数:**

- `arg1` (RDI): `ptr` - 解放するメモリのアドレス (u64)

**戻り値:**

- `ENOSYS`（現在未実装）

---

### 6: sys_fork - プロセスの複製

現在のプロセスを複製して新しい子プロセスを作成します。

**引数:**

- なし

**戻り値:**

- 親プロセス: 子プロセスのPID (正の値)
- 子プロセス: 0
- エラー時: 負のエラーコード
  - `ENOMEM`: メモリ不足

**動作:**

1. 現在のプロセスのページテーブルをコピー
2. プロセス構造体を複製
3. ファイルディスクリプタを共有
4. 子プロセスを `Ready` 状態で作成
5. 親と子で異なる戻り値を返す

**使用例:**

```rust
let pid = syscall!(FORK);
if pid == 0 {
    // 子プロセス
} else if pid > 0 {
    // 親プロセス
} else {
    // エラー
}
```

---

### 7: sys_exec - プログラムの実行

現在のプロセスイメージを新しいプログラムで置き換えます。

**引数:**

- `arg1` (RDI): `path` - 実行するプログラムのパス（将来の実装用、現在は無視）

**戻り値:**

- 成功時: 返らない（プロセスイメージが置き換えられる）
- エラー時: 負のエラーコード
  - `ENOMEM`: メモリ不足

**注意:**

- 現在は埋め込みプログラムのみをサポート
- ファイルシステムからのロードは将来の実装

---

### 8: sys_wait - 子プロセスの待機

子プロセスの終了を待機します。

**引数:**

- `arg1` (RDI): `pid` - 待機するプロセスID（現在は無視、すべての子を対象）
- `arg2` (RSI): `status_ptr` - 終了ステータスを格納するポインタ (u64, オプション)
- `arg3` (RDX): `options` - オプションフラグ（現在未使用）

**戻り値:**

- 成功時: 終了した子プロセスのPID
- エラー時: 負のエラーコード
  - `ECHILD`: 子プロセスが存在しない
  - `ESRCH`: 現在のプロセスが見つからない
  - `EFAULT`: status_ptr が無効

**動作:**

1. 終了した子プロセスを検索
2. 見つかった場合: 終了ステータスを返して子をリープ（解放）
3. 見つからない場合: プロセスをブロックしてスケジューラを呼び出す

**ブロッキング:**

- このシステムコールはブロッキング動作します
- 子プロセスが終了するまで待機

---

### 9: sys_mmap - メモリマッピング

新しいメモリ領域をプロセスのアドレス空間にマッピングします。

**引数:**

- `arg1` (RDI): `addr` - 希望するアドレス（0 = 自動割り当て）
- `arg2` (RSI): `len` - マッピングするバイト数
- `arg3` (RDX): `prot` - 保護フラグ（将来の実装用）
- `arg4` (R10): `flags` - マッピングフラグ（将来の実装用）
- `arg5` (R8): `fd` - ファイルディスクリプタ（将来の実装用）
- `arg6` (R9): `offset` - ファイルオフセット（将来の実装用）

**戻り値:**

- 成功時: マッピングされたメモリのアドレス
- エラー時: 負のエラーコード
  - `EINVAL`: 引数が無効（len = 0、または固定アドレスの指定）
  - `ENOMEM`: メモリ割り当て失敗

**動作:**

1. サイズをページ境界にアライン（4KB）
2. プロセスの mmap 領域から空間を割り当て
3. ページテーブルに新しいページをマッピング
4. メモリをゼロクリア

**メモリレイアウト:**

- mmap 領域: `0x0000_4000_0000_0000` から開始（64TB）

**使用例:**

```rust
let size = 4096; // 4KB
let addr = syscall!(MMAP, 0, size, 0, 0, 0, 0);
if addr >= 0 {
    // メモリが割り当てられた
}
```

---

### 10: sys_munmap - メモリマッピング解除

プロセスのアドレス空間からメモリ領域をアンマップします。

**引数:**

- `arg1` (RDI): `addr` - アンマップするアドレス
- `arg2` (RSI): `len` - アンマップするバイト数

**戻り値:**

- 成功時: 0
- エラー時: 負のエラーコード
  - `EINVAL`: len = 0

**動作:**

1. サイズをページ境界にアライン
2. ページテーブルからページをアンマップ
3. 物理フレームを解放
4. TLBをフラッシュ

---

### 11: sys_pipe - パイプの作成

プロセス間通信用のパイプを作成します。

**引数:**

- `arg1` (RDI): `pipefd` - ファイルディスクリプタペアを格納する配列へのポインタ (`[u64; 2]`)

**戻り値:**

- 成功時: 0
- エラー時: 負のエラーコード
  - `EFAULT`: pipefd が無効
  - `ESRCH`: 現在のプロセスが見つからない

**動作:**

1. 新しいパイプを作成
2. 読み取り用FDと書き込み用FDを作成
3. pipefd[0] に読み取りFD、pipefd[1] に書き込みFDを設定

**使用例:**

```rust
let mut pipefd = [0u64; 2];
let result = syscall!(PIPE, pipefd.as_mut_ptr() as u64);
if result == 0 {
    let read_fd = pipefd[0];
    let write_fd = pipefd[1];
}
```

## セキュリティ考慮事項

### ポインタ検証

すべてのユーザー空間からのポインタは以下の検証を受けます：

1. **アドレス範囲チェック**
   - ユーザー空間: `0x0000_0000_0000_0000` - `0x0000_7FFF_FFFF_FFFF`
   - カーネル空間へのポインタは即座に `EFAULT` エラー

2. **メモリマッピングチェック**（将来の実装）
   - ポインタが実際にマッピングされているか確認
   - 適切なアクセス権限があるか確認

3. **オーバーフローチェック**
   - `addr + len` がオーバーフローしないか確認
   - 境界をまたぐアクセスを拒否

### システムコールの権限

現在の実装では、すべてのシステムコールはすべてのプロセスから呼び出し可能です。将来、以下の機能を追加予定：

- Capability ベースのアクセス制御
- プロセスごとのシステムコールフィルタリング
- セキュアコンピューティングモード（seccomp 相当）

## パフォーマンス

### システムコールのオーバーヘッド

典型的なシステムコール（`sys_getpid`）のオーバーヘッド：

- CPU サイクル: ~200-500 cycles
- 内訳:
  - `syscall` 命令: ~50 cycles
  - スタック切り替え: ~20 cycles
  - ディスパッチ: ~30 cycles
  - `sysret` 命令: ~50 cycles

### 最適化のヒント

1. **バッチ処理**: 可能な限り複数の操作を1つのシステムコールにまとめる
2. **バッファリング**: 頻繁な小さな書き込みの代わりに、バッファリングを使用
3. **非同期I/O**: 将来の実装で非同期システムコールをサポート予定

## 下位互換性

システムコールインターフェースは安定しており、以下のルールに従います：

1. システムコール番号は変更されない
2. 既存のシステムコールの引数は変更されない
3. 新しいシステムコールは末尾に追加される
4. 非推奨のシステムコールは `ENOSYS` を返すが、削除されない

## 将来の拡張

以下の機能が将来のバージョンで追加予定です：

- **非同期I/O**: `sys_io_submit`, `sys_io_getevents`
- **ファイルシステム**: `sys_open`, `sys_close`, `sys_stat`
- **ネットワーク**: `sys_socket`, `sys_bind`, `sys_connect`
- **シグナル**: `sys_kill`, `sys_signal`
- **タイマー**: `sys_nanosleep`, `sys_timer_create`

## 参考資料

- [x86-64 System V ABI](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf)
- [Linux System Call Table](https://filippo.io/linux-syscall-table/)
- [AMD64 Architecture Programmer's Manual Volume 3: General-Purpose and System Instructions](https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24594.pdf)
