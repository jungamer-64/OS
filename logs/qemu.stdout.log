[2J[001;001H[=3h[2J[001;001H[2J[001;001H[8;056;240t[2J[001;001H[2J[001;001H[=3h[2J[001;001H[2J[001;001H[8;042;160t[2J[001;001HBdsDxe: loading Boot0002 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1,0x1)/Ata(Primary,Master,0x0)
BdsDxe: starting Boot0002 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1,0x1)/Ata(Primary,Master,0x0)
INFO : Framebuffer info: FrameBufferInfo { byte_len: 4096000, width: 1280, height: 800, pixel_format: Bgr, bytes_per_pixel: 4, stride: 1280 }
INFO : UEFI bootloader started
INFO : Using framebuffer at 0x80000000
INFO : Reading configuration from disk was successful
INFO : Trying to load ramdisk via Disk
INFO : Ramdisk not found.
TRACE: exiting boot services
TRACE: switching to new level 4 table
INFO : New page table at: PhysFrame[4KiB](0x101000)
INFO : Elf file loaded at Pointer {
    addr: 0x0000000005a31000,
    metadata: 4365368,
}
INFO : virtual_address_offset: 0x0
INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(4), offset: 0, virtual_addr: 200000, physical_addr: 200000, file_size: 10824, mem_size: 10824, align: 1000 })
INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(5), offset: 10830, virtual_addr: 211830, physical_addr: 211830, file_size: 609e7, mem_size: 609e7, align: 1000 })
INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(6), offset: 71218, virtual_addr: 273218, physical_addr: 273218, file_size: 128, mem_size: 9e88, align: 1000 })
INFO : Mapping bss section
INFO : Entry point at: 0x212930
INFO : Creating GDT at PhysAddr(0x128000)
INFO : Map framebuffer
INFO : Map physical memory
INFO : Allocate bootinfo
INFO : Create Memory Map
INFO : Create bootinfo
INFO : Jumping to kernel entry point at VirtAddr(0x212930)
[KERNEL] Entry point reached
[GDT] Using SYSRET-compatible segment order
[GDT DEBUG] Kernel code selector: 0x8
[GDT DEBUG] User data selector: 0x13
[GDT DEBUG] User code selector: 0x1b
[GDT DEBUG] Kernel data selector: 0x20
[GDT DEBUG] TSS selector: 0x28
[GDT DUMP] Base: 0x27d000, Limit: 0x37
[GDT DUMP] Entry 0: offset=0x0, value=0x0000000000000000
[GDT DUMP] Entry 1: offset=0x8, value=0x00af9b000000ffff
    Access=0x9b (P=1, DPL=0, Type=0x1b), Flags=0xa
[GDT DUMP] Entry 2: offset=0x10, value=0x008ff2000000ffff
    Access=0xf2 (P=1, DPL=3, Type=0x12), Flags=0x8
[GDT DUMP] Entry 3: offset=0x18, value=0x00affa000000ffff
    Access=0xfa (P=1, DPL=3, Type=0x1a), Flags=0xa
[GDT DUMP] Entry 4: offset=0x20, value=0x00cf93000000ffff
    Access=0x93 (P=1, DPL=0, Type=0x13), Flags=0xc
[GDT DUMP] Entry 5: offset=0x28, value=0x00008b2740040067
    Access=0x8b (P=1, DPL=0, Type=0xb), Flags=0x0
[GDT DUMP] Entry 6: offset=0x30, value=0x0000000000000000
[GDT] Initialized with new tss.rs module integration
[TSS] Task State Segment initialized
[OK] GDT initialized
[OK] IDT initialized
[DEBUG] Setting up STAR MSR:
  kernel_code: 0x8
  kernel_data: 0x20
  user_code: 0x1B (base: 0x18)
  user_data: 0x13 (base: 0x10)
[OK] STAR MSR written: 0x8000800000000
[OK] Kernel syscall stack initialized at 0x277090
[OK] Syscall mechanism initialized
  STAR: kernel_cs=0x8, user_cs=0x1b
  LSTAR: 0x250fc4
[OK] Physical memory offset initialized: 0x20000000000
[OK] Console initialized
[OK] Paging & Global Frame Allocator initialized
[OK] Heap initialized at 0x20000900000 (Size: 15204352 bytes)
[WARNING] No initrd found!
========================================
  Tiny OS - Ideal Rust Kernel (UEFI)
========================================
[OK] Kernel initialized successfully!
[create_user_page_table] Scanning ALL kernel entries (0-511)...
  Kernel entry 0: addr=0x102000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 2: addr=0x111000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 3: addr=0x12a000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 4: addr=0x12e000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 5: addr=0x32f000, flags=PageTableFlags(PRESENT | WRITABLE)
  Kernel entry 6: addr=0x531000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
[create_user_page_table] Found 6 kernel entries
[create_user_page_table] Copying kernel entries (0-511)
  [COPY] Entry 0: 0x102000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 2: 0x111000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 3: 0x12a000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 4: 0x12e000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 5: 0x32f000 -> flags: PageTableFlags(PRESENT | WRITABLE)
  [COPY] Entry 6: 0x531000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
[create_user_page_table] Copied 6 entries
[create_user_page_table] Copy completed, frame=0x537000
[create_user_page_table] Verifying copied entries:
  User Entry 0: addr=0x102000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 2: addr=0x111000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 3: addr=0x12a000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 4: addr=0x12e000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 5: addr=0x32f000, flags=PageTableFlags(PRESENT | WRITABLE)
  User Entry 6: addr=0x531000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
[create_process] PID=1, page_table_frame=0x537000
[create_user_process] PML4 Entry 0 before load: PageTableEntry { addr: PhysAddr(0x102000), flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED) }
[create] Using ELF loader
=== ELF File Information ===
Entry point: 0x400000
Program headers: 3
Section headers: 4
Loadable segments: 2
Total memory: 2313 bytes
File type: 0x2
============================
[SECURITY] W^X verification: PASSED
[ELF] Loading ELF binary, entry=0x400000
[ELF] Found 3 program headers
[ELF] Memory range: 0x400000 - 0x400909 (2313 bytes)
[ELF] Loading segment 0: vaddr=0x400000, size=0x77c, flags=R-X
[ELF] Copied 1916 bytes to segment 0
[ELF] Loading segment 1: vaddr=0x40077c, size=0x18d, flags=R--
[ELF] Page 0x400000 already mapped, reusing frame
[ELF] Copied 397 bytes to segment 1
[User Paging] Mapping stack: 1048576 bytes (256 pages) at 0x6ffffff00000
[User Paging] Guard page at 0x6fffffeff000 (unmapped)
[User Paging] Stack mapped successfully, top=0x700000000000
[create_user_process] PML4 Entry 0 after load: PageTableEntry { addr: PhysAddr(0x102000), flags: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED) }
[USER PT FIX] Setting USER_ACCESSIBLE on user page table hierarchy...
[USER PT FIX] PML4[0] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[USER PT FIX] PML4[0] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[USER PT FIX] PDPT[0] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[USER PT FIX] PDPT[0] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[USER PT FIX] PD[2] before: PageTableFlags(PRESENT | USER_ACCESSIBLE)
[USER PT FIX] PD[2] after: PageTableFlags(PRESENT | USER_ACCESSIBLE)
[USER PT FIX] PT[0] before: PageTableFlags(PRESENT | USER_ACCESSIBLE)
[USER PT FIX] PT[0] after: PageTableFlags(PRESENT | USER_ACCESSIBLE)
[USER PT FIX] PT[1] before: PageTableFlags(0x0)
[USER PT FIX] PT[1] after: PageTableFlags(0x0)
[USER PT FIX] PML4[223] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] PML4[223] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] PDPT[511] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] PDPT[511] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] PD[511] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] PD[511] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] Updating all stack PT entries (496-511)...
[USER PT FIX] Stack PT[496] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[496] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[497] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[497] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[498] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[498] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[499] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[499] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[500] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[500] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[501] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[501] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[502] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[502] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[503] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[503] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[504] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[504] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[505] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[505] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[506] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[506] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[507] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[507] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[508] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[508] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[509] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[509] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[510] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[510] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[511] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[511] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT entries updated
[VALIDATION] Checking user page table mappings:
[PageTable] User Code Entry: 0x400000 -> frame 0x538000, flags: PageTableFlags(PRESENT | USER_ACCESSIBLE)
[PageTable] User Stack Top: 0x700000000000 -> NOT MAPPED
[VALIDATION] Current kernel RSP: 0x10000011f40
[PageTable] Kernel Stack (iretq frame location): 0x10000011f40 -> frame 0x123000, flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED | DIRTY | NO_EXECUTE)
[PHASE 3 FIX] Adjusting stack top from 0x700000000000 to 0x6ffffffff000
[PHASE 3] CR3 diagnostic tests skipped (Test 2 causes hang)
[PHASE 3] Mapping user code to kernel page table...
[PHASE 3] Kernel CR3: 0x101000
[PHASE 3] PML4[0] has USER_ACCESSIBLE: true
[PHASE 3] Mapping code page 0x400000 -> frame 0x538000
[PHASE 3] Page 0x400000 already mapped in kernel page table
[PHASE 3] User code mapped to kernel page table successfully
[PHASE 3] Mapping user stack to kernel page table...
[PHASE 3] Mapping stack page 0x6ffffffff000 -> frame 0x63c000
[PHASE 3] Mapping stack page 0x6fffffffe000 -> frame 0x63b000
[PHASE 3] Mapping stack page 0x6fffffffd000 -> frame 0x63a000
[PHASE 3] Mapping stack page 0x6fffffffc000 -> frame 0x639000
[PHASE 3] Mapping stack page 0x6fffffffb000 -> frame 0x638000
[PHASE 3] Mapping stack page 0x6fffffffa000 -> frame 0x637000
[PHASE 3] Mapping stack page 0x6fffffff9000 -> frame 0x636000
[PHASE 3] Mapping stack page 0x6fffffff8000 -> frame 0x635000
[PHASE 3] Mapping stack page 0x6fffffff7000 -> frame 0x634000
[PHASE 3] Mapping stack page 0x6fffffff6000 -> frame 0x633000
[PHASE 3] Mapping stack page 0x6fffffff5000 -> frame 0x632000
[PHASE 3] Mapping stack page 0x6fffffff4000 -> frame 0x631000
[PHASE 3] Mapping stack page 0x6fffffff3000 -> frame 0x630000
[PHASE 3] Mapping stack page 0x6fffffff2000 -> frame 0x62f000
[PHASE 3] Mapping stack page 0x6fffffff1000 -> frame 0x62e000
[PHASE 3] Mapping stack page 0x6fffffff0000 -> frame 0x62d000
[PHASE 3] User stack mapped to kernel page table successfully
[PHASE 3] Setting USER_ACCESSIBLE on all used page table hierarchy entries...
[PHASE 3] Updating User code page table hierarchy...
[PHASE 3] PML4[0] before: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[PHASE 3] PML4[0] after: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[PHASE 3] PDPT[0] before: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[PHASE 3] PDPT[0] after: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[PHASE 3] PD[2] before: flags=PageTableFlags(PRESENT | USER_ACCESSIBLE)
[PHASE 3] PD[2] after: flags=PageTableFlags(PRESENT | USER_ACCESSIBLE)
[PHASE 3] PT[0] before: flags=PageTableFlags(PRESENT | USER_ACCESSIBLE)
[PHASE 3] PT[0] after: flags=PageTableFlags(PRESENT | USER_ACCESSIBLE)
[PHASE 3] User code page table hierarchy updated with USER_ACCESSIBLE
[PHASE 3] Updating User stack page table hierarchy...
[PHASE 3] PML4[223] before: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[PHASE 3] PML4[223] after: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[PHASE 3] PDPT[511] before: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[PHASE 3] PDPT[511] after: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[PHASE 3] PD[511] before: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[PHASE 3] PD[511] after: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[PHASE 3] Updating kernel PT entries (496-511) for stack...
[PHASE 3] Kernel stack PT entries updated
[PHASE 3] User stack page table hierarchy updated with USER_ACCESSIBLE
[PHASE 3] TLB flushed
[Process] Created process PID=1
[Process] Created initial user process: PID=1
[Process] Set PID=1 as Running
[Kernel] Entry: 0x400000, Stack: 0x6ffffffff000, CR3: 0x537000
[PHASE 2.5] User mode transition test (CR3 switch skipped)
[TEMP] Interrupts DISABLED for User mode testing
[TSS] Setting kernel stack to 0x200009040c0
[TSS] Updated kernel stack to 0x200009040c0
[Kernel] Jumping to first user process...
[jump_to_usermode] About to use SYSRET:
  RIP=0x400000, RSP=0x6ffffffff000, RFLAGS=0x202
  USER_CODE=0x1B, USER_DATA=0x13, CR3=0x537000
[DEBUG] GDT base: 0x27d000, limit: 0x37
[DEBUG] Current kernel RSP: 0x100000146f0
[DEBUG] Building SYSRET frame:
[DEBUG]   entry_point (RIP->RCX): 0x400000
[DEBUG]   user_stack (RSP): 0x6ffffffff000
[DEBUG]   user_cr3: 0x537000
[DEBUG]   rflags (->R11): 0x202
[DEBUG] Current SS: 0x10, DS: 0x10, ES: 0x10
[jump_to_usermode] Using external NASM function with SYSRET
ABCD[GPF!]
