WHPX: setting APIC emulation mode in the hypervisor
Windows Hypervisor Platform accelerator is operational
[2J[001;001H[=3h[2J[001;001H[2J[001;001H[8;056;240t[2J[001;001H[2J[001;001H[=3h[2J[001;001H[2J[001;001H[8;042;160t[2J[001;001HBdsDxe: loading Boot0002 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1,0x1)/Ata(Primary,Master,0x0)
BdsDxe: starting Boot0002 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1,0x1)/Ata(Primary,Master,0x0)
INFO : Framebuffer info: FrameBufferInfo { byte_len: 4096000, width: 1280, height: 800, pixel_format: Bgr, bytes_per_pixel: 4, stride: 1280 }
INFO : UEFI bootloader started
INFO : Using framebuffer at 0x80000000
INFO : Reading configuration from disk was successful
INFO : Trying to load ramdisk via Disk
INFO : Ramdisk not found.
TRACE: exiting boot services
TRACE: switching to new level 4 table
INFO : New page table at: PhysFrame[4KiB](0x101000)
INFO : Elf file loaded at Pointer {
    addr: 0x0000000006687000,
    metadata: 143416,
}
INFO : virtual_address_offset: 0x0
INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(4), offset: 0, virtual_addr: 200000, physical_addr: 200000, file_size: 8f34, mem_size: 8f34, align: 1000 })
INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(5), offset: 8f40, virtual_addr: 209f40, physical_addr: 209f40, file_size: 19c53, mem_size: 19c53, align: 1000 })
INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(6), offset: 22b98, virtual_addr: 224b98, physical_addr: 224b98, file_size: 124, mem_size: 9618, align: 1000 })
INFO : Mapping bss section
INFO : Entry point at: 0x20ca60
INFO : Creating GDT at PhysAddr(0x128000)
INFO : Map framebuffer
INFO : Map physical memory
INFO : Allocate bootinfo
INFO : Create Memory Map
INFO : Create bootinfo
INFO : Jumping to kernel entry point at VirtAddr(0x20ca60)
[KERNEL] Entry point reached
[GDT] Using manually created user segment descriptors
[GDT DEBUG] Kernel code selector: 0x8
[GDT DEBUG] Kernel data selector: 0x10
[GDT DEBUG] User code selector: 0x1b
[GDT DEBUG] User data selector: 0x23
[GDT DEBUG] TSS selector: 0x28
[GDT DUMP] Base: 0x22e080, Limit: 0x37
[GDT DUMP] Entry 0: offset=0x0, value=0x0000000000000000
[GDT DUMP] Entry 1: offset=0x8, value=0x00af9b000000ffff
    Access=0x9b (P=1, DPL=0, Type=0x1b), Flags=0xa
[GDT DUMP] Entry 2: offset=0x10, value=0x00cf93000000ffff
    Access=0x93 (P=1, DPL=0, Type=0x13), Flags=0xc
[GDT DUMP] Entry 3: offset=0x18, value=0x00affa000000ffff
    Access=0xfa (P=1, DPL=3, Type=0x1a), Flags=0xa
[GDT DUMP] Entry 4: offset=0x20, value=0x00cff2000000ffff
    Access=0xf2 (P=1, DPL=3, Type=0x12), Flags=0xc
[GDT DUMP] Entry 5: offset=0x28, value=0x00008b22e0e40067
    Access=0x8b (P=1, DPL=0, Type=0xb), Flags=0x0
[GDT DUMP] Entry 6: offset=0x30, value=0x0000000000000000
[GDT] Initialized with new tss.rs module integration
[TSS] Task State Segment initialized
[OK] GDT initialized
[OK] IDT initialized
[DEBUG] Setting up STAR MSR:
  kernel_code: 0x8
  kernel_data: 0x10
  user_code: 0x1B (base: 0x18)
  user_data: 0x23 (base: 0x20)
[OK] STAR MSR written: 0x8000800000000
[OK] Kernel syscall stack initialized at 0x22d000
[OK] Syscall mechanism initialized
  STAR: kernel_cs=0x8, user_cs=0x1b
  LSTAR: 0x209f40
[OK] Physical memory offset initialized: 0x18000000000
[OK] Console initialized
[OK] Paging & Global Frame Allocator initialized
[OK] Heap initialized at 0x18000900000 (Size: 15204352 bytes)
[WARNING] No initrd found!
========================================
  Tiny OS - Ideal Rust Kernel (UEFI)
========================================
[OK] Kernel initialized successfully!
[create_user_page_table] Scanning ALL kernel entries (0-511)...
  Kernel entry 0: addr=0x102000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 1: addr=0x111000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 2: addr=0x12a000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 3: addr=0x12e000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 4: addr=0x134000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
[create_user_page_table] Found 5 kernel entries
[create_user_page_table] Copying kernel entries (0-511)
  [COPY] Entry 0: 0x102000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 1: 0x111000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 2: 0x12a000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 3: 0x12e000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 4: 0x134000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
[create_user_page_table] Copied 5 entries
[create_user_page_table] Copy completed, frame=0x13a000
[create_user_page_table] Verifying copied entries:
  User Entry 0: addr=0x102000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 1: addr=0x111000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 2: addr=0x12a000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 3: addr=0x12e000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 4: addr=0x134000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
[create_process] PID=1, page_table_frame=0x13a000
[create_user_process] PML4 Entry 0 before load: PageTableEntry { addr: PhysAddr(0x102000), flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED) }
[create] Using ELF loader
=== ELF File Information ===
Entry point: 0x400000
Program headers: 2
Section headers: 4
Loadable segments: 2
Total memory: 2350 bytes
File type: 0x2