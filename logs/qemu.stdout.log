WHPX: setting APIC emulation mode in the hypervisor
Windows Hypervisor Platform accelerator is operational
[2J[001;001H[=3h[2J[001;001H[2J[001;001H[8;056;240t[2J[001;001H[2J[001;001H[=3h[2J[001;001H[2J[001;001H[8;042;160t[2J[001;001HBdsDxe: loading Boot0002 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1,0x1)/Ata(Primary,Master,0x0)
BdsDxe: starting Boot0002 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1,0x1)/Ata(Primary,Master,0x0)
INFO : Framebuffer info: FrameBufferInfo { byte_len: 4096000, width: 1280, height: 800, pixel_format: Bgr, bytes_per_pixel: 4, stride: 1280 }
INFO : UEFI bootloader started
INFO : Using framebuffer at 0x80000000
INFO : Reading configuration from disk was successful
INFO : Trying to load ramdisk via Disk
INFO : Ramdisk not found.
TRACE: exiting boot services
TRACE: switching to new level 4 table
INFO : New page table at: PhysFrame[4KiB](0x101000)
INFO : Elf file loaded at Pointer {
    addr: 0x0000000006688000,
    metadata: 142536,
}
INFO : virtual_address_offset: 0x0
INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(4), offset: 0, virtual_addr: 200000, physical_addr: 200000, file_size: 8ebc, mem_size: 8ebc, align: 1000 })
INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(5), offset: 8ec0, virtual_addr: 209ec0, physical_addr: 209ec0, file_size: 19966, mem_size: 19966, align: 1000 })
INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(6), offset: 22828, virtual_addr: 224828, physical_addr: 224828, file_size: 124, mem_size: 9988, align: 1000 })
INFO : Mapping bss section
INFO : Entry point at: 0x20c9e0
INFO : Creating GDT at PhysAddr(0x128000)
INFO : Map framebuffer
INFO : Map physical memory
INFO : Allocate bootinfo
INFO : Create Memory Map
INFO : Create bootinfo
INFO : Jumping to kernel entry point at VirtAddr(0x20c9e0)
[KERNEL] Entry point reached
[GDT] Using manually created user segment descriptors
[GDT DEBUG] Kernel code selector: 0x8
[GDT DEBUG] Kernel data selector: 0x10
[GDT DEBUG] User code selector: 0x1b
[GDT DEBUG] User data selector: 0x23
[GDT DEBUG] TSS selector: 0x28
[GDT DUMP] Base: 0x22e080, Limit: 0x37
[GDT DUMP] Entry 0: offset=0x0, value=0x0000000000000000
[GDT DUMP] Entry 1: offset=0x8, value=0x00af9b000000ffff
    Access=0x9b (P=1, DPL=0, Type=0x1b), Flags=0xa
[GDT DUMP] Entry 2: offset=0x10, value=0x00cf93000000ffff
    Access=0x93 (P=1, DPL=0, Type=0x13), Flags=0xc
[GDT DUMP] Entry 3: offset=0x18, value=0x00affa000000ffff
    Access=0xfa (P=1, DPL=3, Type=0x1a), Flags=0xa
[GDT DUMP] Entry 4: offset=0x20, value=0x008ff2000000ffff
    Access=0xf2 (P=1, DPL=3, Type=0x12), Flags=0x8
[GDT DUMP] Entry 5: offset=0x28, value=0x00008b22e0e40067
    Access=0x8b (P=1, DPL=0, Type=0xb), Flags=0x0
[GDT DUMP] Entry 6: offset=0x30, value=0x0000000000000000
[GDT] Initialized with new tss.rs module integration
[TSS] Task State Segment initialized
[OK] GDT initialized
[OK] IDT initialized
[DEBUG] Setting up STAR MSR:
  kernel_code: 0x8
  kernel_data: 0x10
  user_code: 0x1B (base: 0x18)
  user_data: 0x23 (base: 0x20)
[OK] STAR MSR written: 0x8000800000000
[OK] Kernel syscall stack initialized at 0x22d000
[OK] Syscall mechanism initialized
  STAR: kernel_cs=0x8, user_cs=0x1b
  LSTAR: 0x209ec0
[OK] Physical memory offset initialized: 0x18000000000
[OK] Console initialized
[OK] Paging & Global Frame Allocator initialized
[OK] Heap initialized at 0x18000900000 (Size: 15204352 bytes)
[WARNING] No initrd found!
========================================
  Tiny OS - Ideal Rust Kernel (UEFI)
========================================
[OK] Kernel initialized successfully!
[create_user_page_table] Scanning ALL kernel entries (0-511)...
  Kernel entry 0: addr=0x102000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 1: addr=0x111000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 2: addr=0x12a000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 3: addr=0x12e000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  Kernel entry 4: addr=0x134000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
[create_user_page_table] Found 5 kernel entries
[create_user_page_table] Copying kernel entries (0-511)
  [COPY] Entry 0: 0x102000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 1: 0x111000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 2: 0x12a000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 3: 0x12e000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  [COPY] Entry 4: 0x134000 -> flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED)
[create_user_page_table] Copied 5 entries
[create_user_page_table] Copy completed, frame=0x13a000
[create_user_page_table] Verifying copied entries:
  User Entry 0: addr=0x102000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 1: addr=0x111000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 2: addr=0x12a000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 3: addr=0x12e000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
  User Entry 4: addr=0x134000, flags=PageTableFlags(PRESENT | WRITABLE | ACCESSED)
[create_process] PID=1, page_table_frame=0x13a000
[create_user_process] PML4 Entry 0 before load: PageTableEntry { addr: PhysAddr(0x102000), flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED) }
[create] Using ELF loader
=== ELF File Information ===
Entry point: 0x400000
Program headers: 2
Section headers: 4
Loadable segments: 2
Total memory: 2350 bytes
File type: 0x2
============================
[SECURITY] W^X verification: PASSED
[ELF] Loading ELF binary, entry=0x400000
[ELF] Found 2 program headers
[ELF] Memory range: 0x400000 - 0x401292 (4754 bytes)
[ELF] Loading segment 0: vaddr=0x400000, size=0x69c, flags=R-X
[ELF] Copied 1692 bytes to segment 0
[ELF] Loading segment 1: vaddr=0x401000, size=0x292, flags=R--
[ELF] Copied 658 bytes to segment 1
[User Paging] Mapping stack: 65536 bytes (16 pages) at 0x6fffffff0000
[User Paging] Guard page at 0x6ffffffef000 (unmapped)
[User Paging] Stack mapped successfully, top=0x700000000000
[create_user_process] PML4 Entry 0 after load: PageTableEntry { addr: PhysAddr(0x102000), flags: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED) }
[USER PT FIX] Setting USER_ACCESSIBLE on user page table hierarchy...
[USER PT FIX] PML4[0] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[USER PT FIX] PML4[0] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[USER PT FIX] PDPT[0] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[USER PT FIX] PDPT[0] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[USER PT FIX] PD[2] before: PageTableFlags(PRESENT | USER_ACCESSIBLE)
[USER PT FIX] PD[2] after: PageTableFlags(PRESENT | USER_ACCESSIBLE)
[USER PT FIX] PT[0] before: PageTableFlags(PRESENT | USER_ACCESSIBLE)
[USER PT FIX] PT[0] after: PageTableFlags(PRESENT | USER_ACCESSIBLE)
[USER PT FIX] PT[1] before: PageTableFlags(PRESENT | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] PT[1] after: PageTableFlags(PRESENT | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] PML4[223] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] PML4[223] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] PDPT[511] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] PDPT[511] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] PD[511] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] PD[511] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE)
[USER PT FIX] Updating all stack PT entries (496-511)...
[USER PT FIX] Stack PT[496] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[496] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[497] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[497] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[498] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[498] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[499] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[499] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[500] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[500] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[501] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[501] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[502] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[502] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[503] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[503] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[504] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[504] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[505] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[505] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[506] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[506] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[507] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[507] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[508] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[508] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[509] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[509] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[510] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[510] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[511] before: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT[511] after: PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | NO_EXECUTE)
[USER PT FIX] Stack PT entries updated
[VALIDATION] Checking user page table mappings:
[PageTable] User Code Entry: 0x400000 -> frame 0x13b000, flags: PageTableFlags(PRESENT | USER_ACCESSIBLE)
[PageTable] User Stack Top: 0x700000000000 -> NOT MAPPED
[VALIDATION] Current kernel RSP: 0x8000014780
[PageTable] Kernel Stack (iretq frame location): 0x8000014780 -> frame 0x126000, flags: PageTableFlags(PRESENT | WRITABLE | ACCESSED | DIRTY | NO_EXECUTE)
[PHASE 3 FIX] Adjusting stack top from 0x700000000000 to 0x6ffffffff000
[PHASE 3] CR3 diagnostic tests skipped (Test 2 causes hang)
[PHASE 3] Mapping user code to kernel page table...
[PHASE 3] Kernel CR3: 0x101000
[PHASE 3] PML4[0] has USER_ACCESSIBLE: true
[PHASE 3] Mapping code page 0x400000 -> frame 0x13b000
[PHASE 3] Page 0x400000 already mapped in kernel page table
[PHASE 3] Mapping code page 0x401000 -> frame 0x13d000
[PHASE 3] Page 0x401000 already mapped in kernel page table
[PHASE 3] User code mapped to kernel page table successfully
[PHASE 3] Mapping user stack to kernel page table...
[PHASE 3] Mapping stack page 0x6ffffffff000 -> frame 0x150000
[PHASE 3] Mapping stack page 0x6fffffffe000 -> frame 0x14f000
[PHASE 3] Mapping stack page 0x6fffffffd000 -> frame 0x14e000
[PHASE 3] Mapping stack page 0x6fffffffc000 -> frame 0x14d000
[PHASE 3] Mapping stack page 0x6fffffffb000 -> frame 0x14c000
[PHASE 3] Mapping stack page 0x6fffffffa000 -> frame 0x14b000
[PHASE 3] Mapping stack page 0x6fffffff9000 -> frame 0x14a000
[PHASE 3] Mapping stack page 0x6fffffff8000 -> frame 0x149000
[PHASE 3] Mapping stack page 0x6fffffff7000 -> frame 0x148000
[PHASE 3] Mapping stack page 0x6fffffff6000 -> frame 0x147000
[PHASE 3] Mapping stack page 0x6fffffff5000 -> frame 0x146000
[PHASE 3] Mapping stack page 0x6fffffff4000 -> frame 0x145000
[PHASE 3] Mapping stack page 0x6fffffff3000 -> frame 0x144000
[PHASE 3] Mapping stack page 0x6fffffff2000 -> frame 0x143000
[PHASE 3] Mapping stack page 0x6fffffff1000 -> frame 0x142000
[PHASE 3] Mapping stack page 0x6fffffff0000 -> frame 0x13e000
[PHASE 3] User stack mapped to kernel page table successfully
[PHASE 3] Setting USER_ACCESSIBLE on all used page table hierarchy entries...
[PHASE 3] Updating User code page table hierarchy...
[PHASE 3] PML4[0] before: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[PHASE 3] PML4[0] after: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[PHASE 3] PDPT[0] before: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIBLE | ACCESSED)
[PHASE 3] PDPT[0] after: flags=PageTableFlags(PRESENT | WRITABLE | USER_ACCESSIB