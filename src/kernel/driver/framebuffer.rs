//! UEFI Framebuffer ドライバ
//!
//! bootloader_api から渡されるフレームバッファ情報を使用して描画を行います。
//! 簡易的なフォントレンダリング機能を持ちます。

use crate::kernel::core::{Device, CharDevice, KernelResult, DeviceError};
use bootloader_api::info::{FrameBufferInfo, PixelFormat};
use core::fmt;
use spin::{Mutex, Once};

/// グローバルフレームバッファドライバ
pub static FRAMEBUFFER: Once<Mutex<Framebuffer>> = Once::new();

/// フレームバッファを初期化
pub fn init_framebuffer(info: FrameBufferInfo, buffer: &'static mut [u8]) {
    FRAMEBUFFER.call_once(|| {
        let fb = Framebuffer::new(info, buffer);
        Mutex::new(fb)
    });
}

/// フレームバッファにアクセス
pub fn framebuffer() -> &'static Mutex<Framebuffer> {
    FRAMEBUFFER.get().expect("Framebuffer not initialized")
}

/// フレームバッファドライバ
pub struct Framebuffer {
    info: FrameBufferInfo,
    buffer: &'static mut [u8],
    x_pos: usize,
    y_pos: usize,
}

impl Framebuffer {
    pub fn new(info: FrameBufferInfo, buffer: &'static mut [u8]) -> Self {
        let mut fb = Self {
            info,
            buffer,
            x_pos: 0,
            y_pos: 0,
        };
        fb.clear();
        fb
    }

    pub fn clear(&mut self) {
        self.x_pos = 0;
        self.y_pos = 0;
        self.buffer.fill(0);
    }

    pub fn info(&self) -> FrameBufferInfo {
        self.info
    }

    fn newline(&mut self) {
        self.x_pos = 0;
        self.y_pos += 16; // Font height
        
        if self.y_pos + 16 > self.info.height {
            // スクロール処理
            self.scroll_up(16);
            self.y_pos = self.info.height.saturating_sub(16);
        }
    }

    /// 画面を上にスクロール
    fn scroll_up(&mut self, lines: usize) {
        let bytes_per_line = self.info.stride * self.info.bytes_per_pixel * lines;
        let total_bytes = self.info.height * self.info.stride * self.info.bytes_per_pixel;
        
        if bytes_per_line >= total_bytes {
            self.buffer.fill(0);
            return;
        }
        
        unsafe {
            core::ptr::copy(
                self.buffer.as_ptr().add(bytes_per_line),
                self.buffer.as_mut_ptr(),
                total_bytes - bytes_per_line,
            );
        }
        
        self.buffer[total_bytes - bytes_per_line..].fill(0);
    }

    fn write_pixel(&mut self, x: usize, y: usize, intensity: u8) {
        if x >= self.info.width || y >= self.info.height {
            return;
        }

        let pixel_offset = y * self.info.stride + x;
        let bytes_per_pixel = self.info.bytes_per_pixel;
        let byte_offset = pixel_offset * bytes_per_pixel;
        
        if byte_offset + bytes_per_pixel > self.buffer.len() {
            return;
        }

        let dest = &mut self.buffer[byte_offset..byte_offset + bytes_per_pixel];
        
        match self.info.pixel_format {
            PixelFormat::Rgb => {
                if bytes_per_pixel >= 3 {
                    dest[0] = intensity;
                    dest[1] = intensity;
                    dest[2] = intensity;
                }
            }
            PixelFormat::Bgr => {
                if bytes_per_pixel >= 3 {
                    dest[0] = intensity;
                    dest[1] = intensity;
                    dest[2] = intensity;
                }
            }
            PixelFormat::U8 => {
                if bytes_per_pixel >= 1 {
                    dest[0] = intensity;
                }
            }
            _ => {
                if bytes_per_pixel >= 3 {
                    dest[0] = intensity;
                    dest[1] = intensity;
                    dest[2] = intensity;
                }
            }
        }
    }

    pub fn draw_rect(&mut self, x: usize, y: usize, width: usize, height: usize, intensity: u8) {
        for i in 0..width {
            for j in 0..height {
                self.write_pixel(x + i, y + j, intensity);
            }
        }
    }

    pub fn draw_line(&mut self, x1: usize, y1: usize, x2: usize, y2: usize, intensity: u8) {
        let mut x = x1 as isize;
        let mut y = y1 as isize;
        let dx = (x2 as isize - x1 as isize).abs();
        let dy = -(y2 as isize - y1 as isize).abs();
        let sx = if x1 < x2 { 1 } else { -1 };
        let sy = if y1 < y2 { 1 } else { -1 };
        let mut err = dx + dy;

        loop {
            self.write_pixel(x as usize, y as usize, intensity);
            if x == x2 as isize && y == y2 as isize { break; }
            let e2 = 2 * err;
            if e2 >= dy {
                err += dy;
                x += sx;
            }
            if e2 <= dx {
                err += dx;
                y += sy;
            }
        }
    }

    fn write_char(&mut self, c: char) {
        match c {
            '\n' => self.newline(),
            ' '..='~' => {
                if self.x_pos + 8 >= self.info.width {
                    self.newline();
                }
                
                let bitmap = get_bitmap(c);
                for (y, row_byte) in bitmap.iter().enumerate() {
                    for x in 0..8 {
                        if (row_byte >> x) & 1 != 0 {
                            self.write_pixel(self.x_pos + x, self.y_pos + y, 255);
                        } else {
                            self.write_pixel(self.x_pos + x, self.y_pos + y, 0);
                        }
                    }
                }
                self.x_pos += 8;
            }
            _ => {}
        }
    }
}

impl fmt::Write for Framebuffer {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for c in s.chars() {
            self.write_char(c);
        }
        Ok(())
    }
}

impl Device for Framebuffer {
    fn name(&self) -> &str {
        "UEFI Framebuffer"
    }
    
    fn init(&mut self) -> KernelResult<()> {
        self.clear();
        Ok(())
    }
    
    fn reset(&mut self) -> KernelResult<()> {
        self.clear();
        Ok(())
    }
}

impl CharDevice for Framebuffer {
    fn read_byte(&self) -> KernelResult<Option<u8>> {
        // フレームバッファは書き込み専用
        Err(DeviceError::NotFound.into())
    }
    
    fn write_byte(&mut self, byte: u8) -> KernelResult<()> {
        self.write_char(byte as char);
        Ok(())
    }
}

// Basic 8x8 Bitmap Font (IBM PC Code Page 437 inspired)
fn get_bitmap(c: char) -> [u8; 8] {
    match c {
        ' ' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        '!' => [0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18],
        '"' => [0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00],
        '#' => [0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00],
        '$' => [0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00],
        '%' => [0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00],
        '&' => [0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00],
        '\'' => [0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00],
        '(' => [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00],
        ')' => [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00],
        '*' => [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],
        '+' => [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00],
        ',' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30],
        '-' => [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],
        '.' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00],
        '/' => [0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x00],
        '0' => [0x3C, 0x66, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x00],
        '1' => [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00],
        '2' => [0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, 0x00],
        '3' => [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00],
        '4' => [0x0C, 0x1C, 0x3C, 0x6C, 0xFE, 0x0C, 0x0C, 0x00],
        '5' => [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00],
        '6' => [0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00],
        '7' => [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00],
        '8' => [0x3C, 0x66, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00],
        '9' => [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00],
        ':' => [0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00],
        ';' => [0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30],
        '<' => [0x06, 0x18, 0x60, 0xC0, 0x60, 0x18, 0x06, 0x00],
        '=' => [0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00],
        '>' => [0x60, 0x18, 0x06, 0x03, 0x06, 0x18, 0x60, 0x00],
        '?' => [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00],
        '@' => [0x3C, 0x66, 0x6E, 0x6E, 0x60, 0x62, 0x3C, 0x00],
        'A' => [0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00],
        'B' => [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00],
        'C' => [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00],
        'D' => [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00],
        'E' => [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00],
        'F' => [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00],
        'G' => [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00],
        'H' => [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
        'I' => [0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00],
        'J' => [0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00],
        'K' => [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00],
        'L' => [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00],
        'M' => [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00],
        'N' => [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00],
        'O' => [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
        'P' => [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00],
        'Q' => [0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00],
        'R' => [0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00],
        'S' => [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00],
        'T' => [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
        'U' => [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
        'V' => [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
        'W' => [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00],
        'X' => [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00],
        'Y' => [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00],
        'Z' => [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00],
        '[' => [0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00],
        '\\' => [0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00],
        ']' => [0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00],
        '^' => [0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00],
        '_' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF],
        '`' => [0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00],
        'a' => [0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00],
        'b' => [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00],
        'c' => [0x00, 0x00, 0x3C, 0x60, 0x60, 0x60, 0x3C, 0x00],
        'd' => [0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00],
        'e' => [0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00],
        'f' => [0x1C, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x30, 0x00],
        'g' => [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C],
        'h' => [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00],
        'i' => [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00],
        'j' => [0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x3C],
        'k' => [0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00],
        'l' => [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00],
        'm' => [0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0x00],
        'n' => [0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x00],
        'o' => [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00],
        'p' => [0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60],
        'q' => [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06],
        'r' => [0x00, 0x00, 0x5C, 0x62, 0x60, 0x60, 0x60, 0x00],
        's' => [0x00, 0x00, 0x3C, 0x60, 0x3C, 0x06, 0x3C, 0x00],
        't' => [0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x1C, 0x00],
        'u' => [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00],
        'v' => [0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
        'w' => [0x00, 0x00, 0xC6, 0xD6, 0xFE, 0x6C, 0x44, 0x00],
        'x' => [0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00],
        'y' => [0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C],
        'z' => [0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00],
        '{' => [0x0C, 0x18, 0x18, 0x30, 0x18, 0x18, 0x0C, 0x00],
        '|' => [0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
        '}' => [0x30, 0x18, 0x18, 0x0C, 0x18, 0x18, 0x30, 0x00],
        '~' => [0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00],
        _ => [0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF], // Box
    }
}
