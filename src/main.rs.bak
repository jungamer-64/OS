// src/main.rs

#![no_std]
#![no_main]

mod serial;
mod vga_buffer;

use bootloader::{entry_point, BootInfo};
use core::fmt::Write;
use core::panic::PanicInfo;

// Re-export color constants for convenience
use vga_buffer::{COLOR_ERROR, COLOR_INFO, COLOR_PANIC, COLOR_SUCCESS, COLOR_WARNING};

/// Initialize the serial port (COM1)
/// Sets up UART with 38400 baud, 8N1 (8 data bits, no parity, 1 stop bit)
fn serial_init() {
    unsafe {
        let mut data_port: Port<u8> = Port::new(SERIAL_IO_PORT);
        let mut int_en_port: Port<u8> = Port::new(SERIAL_IO_PORT + 1);
        let mut fifo_port: Port<u8> = Port::new(SERIAL_IO_PORT + 2);
        let mut line_ctrl_port: Port<u8> = Port::new(SERIAL_IO_PORT + 3);
        let mut modem_ctrl_port: Port<u8> = Port::new(SERIAL_IO_PORT + 4);

        // Disable interrupts
        int_en_port.write(0x00);

        // Enable DLAB (set baud rate divisor)
        line_ctrl_port.write(0x80);

        // Set divisor to 3 (lo byte) 38400 baud
        data_port.write(0x03);
        int_en_port.write(0x00); // (hi byte)

        // 8 bits, no parity, one stop bit (8N1)
        line_ctrl_port.write(0x03);

        // Enable FIFO, clear them, with 14-byte threshold
        fifo_port.write(0xC7);

        // IRQs enabled, RTS/DSR set
        modem_ctrl_port.write(0x0B);
    }
}

/// Wait for serial transmit buffer to be empty
fn serial_wait_transmit_empty() {
    unsafe {
        let mut line_status_port: Port<u8> = Port::new(SERIAL_LINE_STATUS);
        // Wait until bit 5 (transmit buffer empty) is set
        while (line_status_port.read() & 0x20) == 0 {
            core::hint::spin_loop();
        }
    }
}

/// Write a byte to COM1 (with FIFO check for hardware compatibility)
fn serial_write_byte(byte: u8) {
    serial_wait_transmit_empty();
    unsafe {
        let mut port: Port<u8> = Port::new(SERIAL_IO_PORT);
        port.write(byte);
    }
}

/// Write a string to serial port
fn serial_write_str(s: &str) {
    for &b in s.as_bytes() {
        serial_write_byte(b);
    }
}

/// Serial writer for core::fmt::Write trait
struct SerialWriter;

impl Write for SerialWriter {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        serial_write_str(s);
        Ok(())
    }
}

/// VGA text buffer constants
const VGA_BUFFER: usize = 0xb8000;
const VGA_WIDTH: usize = 80;
const VGA_HEIGHT: usize = 25;

/// VGA color codes
#[allow(dead_code)]
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum VgaColor {
    Black = 0,
    Blue = 1,
    Green = 2,
    Cyan = 3,
    Red = 4,
    Magenta = 5,
    Brown = 6,
    LightGray = 7,
    DarkGray = 8,
    LightBlue = 9,
    LightGreen = 10,
    LightCyan = 11,
    LightRed = 12,
    Pink = 13,
    Yellow = 14,
    White = 15,
}

/// Create VGA color byte from foreground and background colors
const fn vga_color_code(fg: VgaColor, bg: VgaColor) -> u8 {
    (bg as u8) << 4 | (fg as u8)
}

/// Default color schemes
const COLOR_NORMAL: u8 = vga_color_code(VgaColor::LightGray, VgaColor::Black);
const COLOR_INFO: u8 = vga_color_code(VgaColor::LightCyan, VgaColor::Black);
const COLOR_SUCCESS: u8 = vga_color_code(VgaColor::LightGreen, VgaColor::Black);
const COLOR_WARNING: u8 = vga_color_code(VgaColor::Yellow, VgaColor::Black);
const COLOR_ERROR: u8 = vga_color_code(VgaColor::LightRed, VgaColor::Black);
const COLOR_PANIC: u8 = vga_color_code(VgaColor::White, VgaColor::Red);

/// VGA Writer structure - encapsulates all VGA state
struct VgaWriter {
    row: usize,
    col: usize,
    color_code: u8,
    buffer: *mut u8,
}

// SAFETY: VGA buffer is always accessible and we're in a single-threaded kernel
// The Mutex ensures exclusive access, so this is safe
unsafe impl Send for VgaWriter {}
unsafe impl Sync for VgaWriter {}

/// Global VGA writer protected by Mutex (SAFE!)
/// Using spin::Mutex directly instead of lazy_static for better compatibility
static VGA_WRITER: Mutex<VgaWriter> = Mutex::new(VgaWriter {
    row: 0,
    col: 0,
    color_code: COLOR_NORMAL,
    buffer: VGA_BUFFER as *mut u8,
});

impl VgaWriter {
    /// Set text color
    fn set_color(&mut self, color: u8) {
        self.color_code = color;
    }

    /// Clear the entire screen
    fn clear(&mut self) {
        for row in 0..VGA_HEIGHT {
            self.clear_row(row);
        }
        self.row = 0;
        self.col = 0;
        self.color_code = COLOR_NORMAL;
    }

    /// Clear a specific row
    fn clear_row(&mut self, row: usize) {
        let blank = (self.color_code as u16) << 8 | b' ' as u16;
        for col in 0..VGA_WIDTH {
            let pos = (row * VGA_WIDTH + col) * 2;
            unsafe {
                *(self.buffer.offset(pos as isize) as *mut u16) = blank;
            }
        }
    }

    /// Scroll the screen up by one line (optimized with copy_nonoverlapping)
    fn scroll(&mut self) {
        // Copy all rows up by one line (much faster than byte-by-byte)
        for row in 1..VGA_HEIGHT {
            let src = (row * VGA_WIDTH * 2) as isize;
            let dst = ((row - 1) * VGA_WIDTH * 2) as isize;
            unsafe {
                core::ptr::copy_nonoverlapping(
                    self.buffer.offset(src),
                    self.buffer.offset(dst),
                    VGA_WIDTH * 2, // 1 row in bytes
                );
            }
        }
        self.clear_row(VGA_HEIGHT - 1);
        self.row = VGA_HEIGHT - 1;
    }

    /// Move to a new line
    fn new_line(&mut self) {
        self.col = 0;
        self.row += 1;
        if self.row >= VGA_HEIGHT {
            self.scroll();
        }
    }

    /// Write a single byte to the screen
    fn write_byte(&mut self, byte: u8) {
        match byte {
            b'\n' => self.new_line(),
            byte => {
                if self.col >= VGA_WIDTH {
                    self.new_line();
                }
                let pos = (self.row * VGA_WIDTH + self.col) * 2;
                unsafe {
                    *self.buffer.offset(pos as isize) = byte;
                    *self.buffer.offset((pos + 1) as isize) = self.color_code;
                }
                self.col += 1;
            }
        }
    }

    /// Write a string with temporary color
    fn write_colored(&mut self, s: &str, color: u8) {
        let old_color = self.color_code;
        self.set_color(color);
        self.write_str(s).unwrap();
        self.set_color(old_color);
    }
}

/// Implement Write trait for VgaWriter (enables write! and writeln! macros)
impl Write for VgaWriter {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for byte in s.bytes() {
            // Only display printable ASCII or newline
            if (0x20..=0x7e).contains(&byte) || byte == b'\n' {
                self.write_byte(byte);
            } else {
                // Replace non-printable with ■ (0xfe)
                self.write_byte(0xfe);
            }
        }
        Ok(())
    }
}

/// Global print! macro (safe version)
#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => ($crate::_print(format_args!($($arg)*)));
}

/// Global println! macro (safe version)
#[macro_export]
macro_rules! println {
    () => ($crate::print!("\n"));
    ($($arg:tt)*) => ($crate::print!("{}\n", format_args!($($arg)*)));
}

/// Print function called by macros
/// SAFETY: Uses without_interrupts to prevent deadlock when interrupts handlers call println!
#[doc(hidden)]
pub fn _print(args: fmt::Arguments) {
    use core::fmt::Write;
    use x86_64::instructions::interrupts;

    // 割り込みを無効化してからロックを取得 (デッドロック防止)
    interrupts::without_interrupts(|| {
        VGA_WRITER.lock().write_fmt(args).unwrap();
    });
}

/// Helper function to clear the screen (public API)
/// SAFETY: Uses without_interrupts to prevent deadlock
pub fn vga_clear() {
    use x86_64::instructions::interrupts;
    interrupts::without_interrupts(|| {
        VGA_WRITER.lock().clear();
    });
}

/// Helper function to set color (public API)
/// SAFETY: Uses without_interrupts to prevent deadlock
pub fn vga_set_color(color: u8) {
    use x86_64::instructions::interrupts;
    interrupts::without_interrupts(|| {
        VGA_WRITER.lock().set_color(color);
    });
}

/// Helper function for colored output (public API)
/// SAFETY: Uses without_interrupts to prevent deadlock
pub fn vga_print_colored(s: &str, color: u8) {
    use x86_64::instructions::interrupts;
    interrupts::without_interrupts(|| {
        VGA_WRITER.lock().write_colored(s, color);
    });
}

entry_point!(kernel_main);

fn kernel_main(_boot_info: &'static BootInfo) -> ! {
    // Initialize serial port
    serial_init();
    serial_write_str("=== Rust OS Kernel Started ===\n");
    serial_write_str("Serial port initialized (38400 baud, 8N1, FIFO checked)\n");

    // Clear VGA screen
    serial_write_str("About to call vga_clear()...\n");
    vga_clear();
    serial_write_str("vga_clear() succeeded!\n");

    // Write to both serial and VGA
    serial_write_str("VGA text mode initialized (80x25, color support)\n");
    serial_write_str("SAFE: Using Mutex-protected VGA writer (no more static mut!)\n");

    // VGA output with new safe println! macro
    serial_write_str("About to use vga_print_colored...\n");
    vga_print_colored("=== Rust OS Kernel Started ===\n", COLOR_INFO);
    serial_write_str("vga_print_colored succeeded!\n");

    serial_write_str("About to use println!...\n");
    println!("Welcome to minimal x86_64 Rust OS!");
    serial_write_str("println! succeeded!\n");

    vga_print_colored("bootloader: ", COLOR_INFO);
    println!("0.9.33");
    vga_print_colored("Serial: ", COLOR_INFO);
    println!("COM1 (0x3F8) with FIFO check\n");

    vga_print_colored("✓ Major Improvements:\n", COLOR_SUCCESS);
    println!("  • Replaced static mut with Mutex (SAFE!)");
    println!("  • Implemented fmt::Write trait");
    println!("  • Added print!/println! macros");
    println!("  • Optimized scroll with copy_nonoverlapping");
    println!("  • Serial FIFO transmit check");
    println!("  • VGA color support (16 colors)");
    println!("  • VGA auto-scroll");
    println!("  • CPU hlt instruction");
    println!("  • Detailed panic handler\n");

    serial_write_str("\n✓ Kernel features:\n");
    serial_write_str("  • SAFE: Mutex-protected VGA writer (no data races!)\n");
    serial_write_str("  • print!/println! macros (fmt::Write trait)\n");
    serial_write_str("  • Optimized memory copy for scroll\n");
    serial_write_str("  • Serial port with FIFO check (hardware-safe)\n");
    serial_write_str("  • VGA text mode with 16-color support\n");
    serial_write_str("  • VGA auto-scroll support\n");
    serial_write_str("  • CPU halt with hlt instruction\n");
    serial_write_str("  • Panic handler with location info\n");

    vga_print_colored("\nNote: ", COLOR_WARNING);
    println!("All features tested and working!");

    serial_write_str("\nKernel running. System in low-power hlt loop.\n");
    serial_write_str("Press Ctrl+A, X to exit QEMU.\n");

    vga_print_colored("\nDemo: ", COLOR_INFO);
    println!("Formatted output: {} + {} = {}", 42, 58, 100);
    vga_print_colored("Demo: ", COLOR_INFO);
    println!("Hexadecimal: {:#x}, Binary: {:#b}", 255, 15);

    // Halt CPU in infinite loop
    loop {
        x86_64::instructions::hlt();
    }
}

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    // Serial output (detailed)
    serial_write_str("\n");
    serial_write_str("═══════════════════════════════════════\n");
    serial_write_str("       !!! KERNEL PANIC !!!\n");
    serial_write_str("═══════════════════════════════════════\n");

    // Print panic message
    let message = info.message();
    let _ = write!(SerialWriter, "Message: {:?}\n", message);

    // Print location
    if let Some(location) = info.location() {
        let _ = write!(
            SerialWriter,
            "Location: {}:{}:{}\n",
            location.file(),
            location.line(),
            location.column()
        );
    }

    serial_write_str("═══════════════════════════════════════\n");
    serial_write_str("System halted. CPU in hlt loop.\n");

    // VGA output (prominent with color - now using safe println!)
    println!();
    vga_print_colored("!!! KERNEL PANIC !!!\n", COLOR_PANIC);
    println!();

    if let Some(location) = info.location() {
        vga_print_colored("File: ", COLOR_ERROR);
        println!("{}", location.file());
        vga_print_colored("Line: ", COLOR_ERROR);
        println!("{}", location.line());
        vga_print_colored("Column: ", COLOR_ERROR);
        println!("{}", location.column());
    }

    println!();
    vga_print_colored(
        "System halted. See serial for more details.\n",
        COLOR_WARNING,
    );

    // Halt CPU forever
    loop {
        x86_64::instructions::hlt();
    }
}
