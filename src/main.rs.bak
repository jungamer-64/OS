//! Tiny OS - 理想的な Rust カーネル
//!
//! trait ベースの抽象化と型安全性を最大化したカーネルアーキテクチャ
//!
//! # 機能
//!
//! - デバイス trait による統一的なドライバインターフェース
//! - 型安全な MMIO とポート I/O
//! - リンクリストヒープアロケータ
//! - ビットマップフレームアロケータ
//! - Future ベースの非同期処理基盤
//!
//! # アーキテクチャ
//!
//! - `kernel/core` - trait, types, result, prelude
//! - `kernel/driver` - デバイスドライバ (Serial, VGA, Keyboard)
//! - `kernel/mm` - メモリ管理 (paging, allocator, frame)
//! - `kernel/async` - 非同期処理 (executor, waker, timer)
//! - `arch/x86_64` - アーキテクチャ依存コード

#![no_std]
#![no_main]
#![deny(unsafe_op_in_unsafe_fn)]
#![warn(missing_docs)]
#![allow(missing_docs)]

extern crate alloc;

use tiny_os::println;
// use tiny_os::constants::{HEAP_START, HEAP_SIZE};
use bootloader_api::{entry_point, BootInfo};
use core::panic::PanicInfo;
use core::fmt::Write;
use tiny_os::arch::{Cpu, ArchCpu};

entry_point!(kernel_main);

fn kernel_main(boot_info: &'static mut BootInfo) -> ! {
    // GDT/IDT 初期化
    tiny_os::arch::x86_64::init_gdt();
    tiny_os::arch::x86_64::init_idt();

    // Framebuffer 初期化
    if let Some(framebuffer) = boot_info.framebuffer.as_mut() {
        let info = framebuffer.info();
        let buffer = framebuffer.buffer_mut();
        tiny_os::kernel::driver::framebuffer::init_framebuffer(info, buffer);
    }

    // ヘッダー表示
    println!("========================================");
    println!("  Tiny OS - Ideal Rust Kernel (UEFI)");
    println!("========================================");
    println!();

    println!("[OK] GDT initialized");
    println!("[OK] IDT initialized");
    
    if tiny_os::kernel::driver::framebuffer::FRAMEBUFFER.get().is_some() {
        println!("[OK] Framebuffer initialized");
    } else {
        println!("[WARN] Framebuffer not available");
    }

    // ヒープ初期化
    println!("Initializing Heap...");
    let heap_result = (|| {
        let (heap_start, heap_size) = tiny_os::kernel::mm::init_heap(&boot_info.memory_regions)?;
        
        unsafe {
            tiny_os::init_heap(heap_start, heap_size);
        }
        
        Ok::<_, &str>((heap_start, heap_size))
    })();

    match heap_result {
        Ok((start, size)) => {
            println!("[OK] Heap initialized at {:#x} (Size: {} bytes)", start, size);
            
            // ヒープ割り当てテスト
            use alloc::boxed::Box;
            use alloc::vec::Vec;
            let test_box = Box::new(42);
            println!("  - Box test: {}", *test_box);
            let mut test_vec = Vec::new();
            test_vec.push(1);
            test_vec.push(2);
            test_vec.push(3);
            println!("  - Vec test: {:?}", test_vec);
        },
        Err(e) => {
            println!("[ERR] Heap initialization failed: {}", e);
            panic!("Heap initialization failed");
        }
    }
    
    // PIC/PIT 初期化
    println!("Initializing Hardware Timer...");
    unsafe {
        tiny_os::arch::x86_64::pic::PICS.lock().initialize();
        tiny_os::kernel::driver::pit::PIT.lock().set_frequency(100).expect("Failed to set PIT frequency");
        tiny_os::arch::x86_64::pic::PICS.lock().unmask_irq(0); // Timer
        tiny_os::arch::x86_64::pic::PICS.lock().unmask_irq(1); // Keyboard
    }
    println!("[OK] Hardware Timer initialized");

    // 割り込み有効化
    println!("Enabling Interrupts...");
    ArchCpu::enable_interrupts();
    println!("[OK] Interrupts enabled");
    
    // カーネル情報表示
    println!();
    println!("Kernel Information:");
    println!("  - Architecture: x86_64");
    println!("  - Boot Protocol: UEFI");
    println!("  - Async Runtime: Future Executor");
    
    // ブート情報表示
    if let Some(fb) = tiny_os::kernel::driver::framebuffer::FRAMEBUFFER.get() {
        let info = fb.lock().info();
        println!("  - Framebuffer: {}x{} ({:?})", info.width, info.height, info.pixel_format);
    }
    if let Some(rsdp_addr) = boot_info.rsdp_addr.into_option() {
        println!("  - RSDP Address: {:#x}", rsdp_addr);
    }
    println!();
    
    println!("========================================");
    println!("  Kernel initialized successfully!");
    println!("========================================");
    println!();
    println!("Entering halt loop...");
    
    // Halt loop
    loop {
        ArchCpu::halt();
    }
}

/// Panic handler
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    use tiny_os::arch::Cpu;
    
    // 割り込みを無効化
    ArchCpu::disable_interrupts();
    
    // VGA が初期化されていれば使用
    if let Some(vga) = tiny_os::kernel::driver::vga::VGA.get() {
        let _ = writeln!(vga.lock(), "\n\n[KERNEL PANIC]\n{}", info);
    }
    
    // Framebuffer が初期化されていれば使用
    if let Some(fb) = tiny_os::kernel::driver::framebuffer::FRAMEBUFFER.get() {
        let _ = writeln!(fb.lock(), "\n\n[KERNEL PANIC]\n{}", info);
    }
    
    // Halt loop
    loop {
        ArchCpu::halt();
    }
}
