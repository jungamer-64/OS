// src/lib.rs
#![no_std]
#![cfg_attr(test, no_main)]
#![cfg_attr(test, feature(custom_test_frameworks))]
#![cfg_attr(test, test_runner(crate::test_runner))]
#![cfg_attr(test, reexport_test_harness_main = "test_main")]
#![deny(unsafe_op_in_unsafe_fn)]
#![warn(missing_docs)]
#![allow(missing_docs)]

//! Tiny OS core library exposing shared kernel functionality.

pub mod constants;
pub mod diagnostics;
pub mod display;
pub mod errors;
pub mod init;
pub mod memory;
pub mod panic;
pub mod qemu;
pub mod serial;
pub mod sync;
pub mod vga_buffer;
pub mod arch;
pub mod framebuffer;

pub use qemu::{exit_qemu, QemuExitCode};

use core::panic::PanicInfo;
use crate::arch::{Cpu, ArchCpu};

/// Halt loop used by tests after executing all test cases.
#[inline]
pub fn hlt_loop() -> ! {
    loop {
        // SAFETY: `hlt` is safe in ring 0 and we never leave the loop.
        ArchCpu::halt();
    }
}

/// Trait implemented for each test function in the custom test framework.
pub trait Testable {
    /// Run the test case and emit diagnostic output.
    fn run(&self);
}

impl<T> Testable for T
where
    T: Fn(),
{
    fn run(&self) {
        crate::print!("[TEST] {} ... ", core::any::type_name::<T>());
        self();
        crate::println!("ok");
    }
}

/// Custom test runner invoked by the `bootimage` test harness.
pub fn test_runner(tests: &[&dyn Testable]) {
    crate::println!("[TEST RUNNER] running {} tests", tests.len());
    for test in tests {
        test.run();
    }
    exit_qemu(QemuExitCode::Success);
}

/// Panic handler used while running kernel tests inside QEMU.
#[cfg(all(test, feature = "std-tests"))]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    test_panic_handler(info)
}

/// Panic handler delegate for tests.
#[inline(never)]
pub fn test_panic_handler(info: &PanicInfo) -> ! {
    crate::println!("[TEST PANIC] {}", info);
    exit_qemu(QemuExitCode::Failed);
}

#[cfg(all(test, feature = "std-tests"))]
use bootloader_api::BootInfo;
#[cfg(all(test, feature = "std-tests"))]
extern "Rust" {
    fn test_main();
}

/// Entry point used when running `bootimage test` so that we can execute the
/// re-exported `test_main` generated by the custom test framework.
#[cfg(all(test, feature = "std-tests"))]
bootloader_api::entry_point!(test_kernel_main);

#[cfg(all(test, feature = "std-tests"))]
fn test_kernel_main(_boot_info: &'static mut BootInfo) -> ! {
    if let Err(err) = init::initialize_all() {
        println!("[TEST INIT] initialization failed: {:?}", err);
    }

    test_main();
    hlt_loop();
}
