#![no_std]
#![cfg_attr(test, no_main)]
#![cfg_attr(test, feature(custom_test_frameworks))]
#![cfg_attr(test, test_runner(crate::test_runner))]
#![cfg_attr(test, reexport_test_harness_main = "test_main")]
#![deny(unsafe_op_in_unsafe_fn)]
#![warn(missing_docs)]
#![allow(missing_docs)]

//! Tiny OS core library exposing shared kernel functionality.

pub mod constants;
pub mod diagnostics;
pub mod display;
pub mod errors;
pub mod init;
pub mod qemu;
pub mod serial;
pub mod vga_buffer;

pub use qemu::{exit_qemu, QemuExitCode};

use core::any::type_name;
use core::panic::PanicInfo;
use x86_64::instructions::hlt;

/// Halt loop used by tests after executing all test cases.
#[inline(always)]
pub fn hlt_loop() -> ! {
    loop {
        // SAFETY: `hlt` is safe in ring 0 and we never leave the loop.
        hlt();
    }
}

/// Trait implemented for each test function in the custom test framework.
pub trait Testable {
    /// Run the test case and emit diagnostic output.
    fn run(&self);
}

impl<T> Testable for T
where
    T: Fn(),
{
    fn run(&self) {
        serial_print!("[TEST] {} ... ", type_name::<T>());
        self();
        serial_println!("ok");
    }
}

/// Custom test runner invoked by the `bootimage` test harness.
pub fn test_runner(tests: &[&dyn Testable]) {
    serial_println!("[TEST RUNNER] running {} tests", tests.len());
    for test in tests {
        test.run();
    }
    exit_qemu(QemuExitCode::Success);
}

/// Panic handler used while running kernel tests inside QEMU.
#[cfg(test)]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    test_panic_handler(info)
}

/// Panic handler delegate for tests.
#[inline(never)]
pub fn test_panic_handler(info: &PanicInfo) -> ! {
    serial_println!("[TEST PANIC] {}", info);
    exit_qemu(QemuExitCode::Failed);
}

#[cfg(test)]
use bootloader::BootInfo;
#[cfg(test)]
extern "Rust" {
    fn test_main();
}

/// Entry point used when running `bootimage test` so that we can execute the
/// re-exported `test_main` generated by the custom test framework.
#[cfg(test)]
bootloader::entry_point!(test_kernel_main);

#[cfg(test)]
fn test_kernel_main(_boot_info: &'static BootInfo) -> ! {
    if let Err(err) = init::initialize_all() {
        serial_println!("[TEST INIT] initialization failed: {:?}", err);
    }

    unsafe {
        test_main();
    }
    hlt_loop();
}
